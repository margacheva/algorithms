# Алгоритм очень прост. Мы проходимся по каждому элементу нашего дерева,
# постоянно перезаписывая элементы уровня.
# Сложность O(n^2)

def averageOfLevels(self, root):
    if not root:  # сразу проверяем, что дерево не пустое
        return []  # в этом случае возваращем пустой список
    result = []  # создаем список, в который будет записывать итоговые значения
    level = [root]  # создаем список, равныйнашему бинарному дереву(далее также будем его перезаписывать,
    # но пока что нам нужен первый элемент)

    while level:  # проходимся по дереву, пока не дойдем до конца
        current_level_values = []  # создаем список, в который будем записывать значения уровня,
        # на котором находимся
        next_level_values = []  # список, в который будем записывать значения на следующем уровне

        for e in level:  # проходимся по каждому элементу в наем дереве
            current_level_values.append(e.val)  # добавляем значение первого элементы в соответсвующий список
            if e.left:  # если есть элемент слева
                next_level_values.append(e.left)  # добавляем его в соответсвующий список следующего уровня
            if e.right:  # если есть элемент справа
                next_level_values.append(e.right)  # добавляем его в соответсвующий список следующего уровня

        result.append(
            sum(current_level_values) / len(current_level_values))  # в итоговый список добавляем среднее арифметическое
        # элементов на данном уровне
        level = next_level_values  # переходим на следующий уровень

    return result  # соответственно возвращаем результат
