# Сложность алгоритма O(nlogn) так как используется метод .sort()

# Функция для вычисления разницы между aCost и bCost
def diff_cost(pair):
    return pair[0] - pair[1]


def two_city_scheduling(costs):
    # Сортировка списка costs по разнице между aCost и bCost
    costs.sort(key=diff_cost)  # используем функцию как эдемент сравнения

    total_cost = 0  # Переменная для хранения общей стоимости

    n = len(costs) // 2  # Вычисление количества людей, которые должны отправиться в город a и b

    for i in range(n):
        total_cost += costs[i][0]  # Отправляем первые n человек в город a
        total_cost += costs[i + n][1]  # Отправляем оставшихся в город b

    return total_cost


print(two_city_scheduling(costs=[[10, 20], [30, 200], [400, 50], [30, 20]]))
# сортировка позволяет вычислить наименьшии числа которые отправятся в город а,
# и вынести наименьшии числа б во вторую половину. Циклом мы добавляем числа из первой половины в город а,
# а потом переходим на вторую половину списка и уже считаем наименьшие числа для отправки в б
